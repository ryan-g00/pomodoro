<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>êµ´ëŸ¬ë¼êµ´ëŸ¬ì •í•´ëŸ‰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>

    <link rel="icon" href="A_digital_vector_graphic_displays_a_minimalist,_fl.png" type="image/png">
    <link rel="apple-touch-icon" href="A_digital_vector_graphic_displays_a_minimalist,_fl.png">
    <link rel="manifest" href="manifest.json">

    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --text-color: #ffffff;
            --text-color-rgb: 255, 255, 255;
            --primary-color: #ff4d4d;
            --secondary-color: #4caf50;
            --accent-color: #2196f3;
            --border-color: #333;
            --input-bg-color: #2a2a2a;
            --input-bg-hover: #3a3a3a;
            --highlight-color: rgba(255, 255, 255, 0.1);
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.5s, color 0.5s;
        }
        
        body.light-theme {
            --bg-color: #f5f5f7;
            --surface-color: #ffffff;
            --text-color: #1d1d1f;
            --text-color-rgb: 29, 29, 31;
            --border-color: #d1d1d6;
            --input-bg-color: #e5e5e5;
            --input-bg-hover: #d5d5d5;
            --highlight-color: rgba(0, 0, 0, 0.05);
        }
        
        /* íœ´ì‹ ëª¨ë“œì¼ ë•Œ ì ìš©í•  ìŠ¤íƒ€ì¼ - ìƒ‰ìƒ ë°˜ì „ */
        body.break-mode {
            transition: background-color 0.5s, color 0.5s;
        }
        
        body.dark-theme.break-mode {
            background-color: #f5f5f7;
            color: #1d1d1f;
        }
        
        body.light-theme.break-mode {
            background-color: #121212;
            color: #ffffff;
        }
        
        /* íœ´ì‹ ëª¨ë“œì¼ ë•Œ UI ìš”ì†Œ ìƒ‰ìƒ ë°˜ì „ */
        body.break-mode .timer-time,
        body.break-mode .set-display,
        body.break-mode .timer-button {
            color: inherit;
        }
        
        .app-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1; /* í•„ìš”ì— ë”°ë¼ z-index ì„¤ì • */
            touch-action: none;
        }
        
        .timer-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: relative;
            touch-action: none;
        }
        .timer-display {
            position: relative;
            width: 95vmin;
            height: 95vmin;
            max-width: 700px;
            max-height: 700px;
            margin: 0 auto;
            touch-action: none;
        }
        
        .timer-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .timer-time {
            position: fixed;
            bottom: 70px;
            left: 30px;
            font-size: 45px;
            font-weight: 600;
            color: var(--text-color);
            z-index: 10;
            transition: color 0.3s;
        }
        
        .time-preview {
            position: fixed; 
            bottom: 70px;
            left: 30px;
            font-size: 45px;
            font-weight: 600;
            color: var(--text-color);
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            display: none;
            pointer-events: none;
            z-index: 11;
            transition: color 0.3s;
        }
        
        .set-display {
            position: fixed;
            bottom: 40px;
            left: 30px;
            font-size: 25px;
            font-weight: 500;
            color: var(--text-color);
            transition: color 0.3s;
        }
        
        body.dark-theme.break-mode .timer-time,
        body.dark-theme.break-mode .time-preview,
        body.dark-theme.break-mode .set-display {
            color: #1d1d1f;
        }
        
        body.light-theme.break-mode .timer-time,
        body.light-theme.break-mode .time-preview,
        body.light-theme.break-mode .set-display {
            color: #ffffff;
        }

        .sets-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }
        
        .sets-label {
            flex: 1;
        }
        
        .sets-counter {
            display: flex;
            align-items: center;
            background-color: var(--input-bg-color);
            border-radius: 4px;
            overflow: hidden;
            transition: background-color 0.3s;
        }
        
        .sets-button {
            width: 36px;
            height: 36px;
            background-color: var(--input-bg-color);
            border: none;
            color: var(--text-color);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .sets-button:hover:not(:disabled) {
            background-color: var(--input-bg-hover);
        }
        
        .sets-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .sets-value {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: var(--text-color);
            transition: color 0.3s;
        }
        
        .timer-actions {
            position: fixed;
            bottom: 40px;
            right: 30px;
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        
        .timer-button {
            background: none;
            color: var(--text-color);
            border: none;
            width: 40px;
            height: 40px;
            font-size: 30px;
            cursor: pointer;
            transition: opacity 0.3s, color 0.3s;
            opacity: 0.8;
            padding: 0;
        }
        
        /* íœ´ì‹ ëª¨ë“œì¼ ë•Œ ë²„íŠ¼ ìƒ‰ìƒ ë°˜ì „ */
        body.dark-theme.break-mode .timer-button {
            color: #1d1d1f;
        }
        
        body.light-theme.break-mode .timer-button {
            color: #ffffff;
        }
        .timer-button:hover {
            opacity: 1;
            color: var(--text-color);
        }
        
        .menu-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 24px;
            cursor: pointer;
            z-index: 1000;
            transition: color 0.3s;
        }
        
        /* íœ´ì‹ ëª¨ë“œì¼ ë•Œ ë©”ë‰´ ë²„íŠ¼ ìƒ‰ìƒ ë°˜ì „ */
        body.dark-theme.break-mode .menu-button {
            color: #1d1d1f;
        }
        
        body.light-theme.break-mode .menu-button {
            color: #ffffff;
        }
        
        .sidebar {
            position: fixed;
            top: 0;
            left: -300px;
            width: 300px;
            height: 100%;
            background-color: var(--surface-color);
            transition: left 0.3s, background-color 0.3s;
            overflow-y: auto;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            color: var(--text-color);
        }
        
        .sidebar.open {
            left: 0;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 999;
        }
        
        .overlay.active {
            display: block;
        }
        
        .sidebar-header {
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
            color: var(--text-color);
            font-weight: bold;
        }
        
        .sidebar-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .sidebar-section:last-child {
            border-bottom: none;
        }
        
        /* ì‹œê°„ í”½ì»¤ ìŠ¤íƒ€ì¼ ì¶”ê°€ */
        .time-pickers {
            display: flex;
            gap: 10px;
        }
        
        .time-picker {
            flex: 1;
        }
        
        .time-picker-label {
            display: block;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .picker-container {
            position: relative;
            height: 120px;
            overflow: hidden;
            border-radius: 8px;
            background-color: var(--input-bg-color);
            transition: background-color 0.3s;
        }
        
        .picker-highlight {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 40px;
            transform: translateY(-50%);
            background-color: var(--highlight-color);
            pointer-events: none;
            transition: background-color 0.3s;
        }
        
        .picker-values {
            height: 100%;
            box-sizing: border-box;
            overflow-y: auto;
            scroll-snap-type: y mandatory;
            padding: 40px 0;
            -webkit-overflow-scrolling: touch;
            transform: translateZ(0);
            scrollbar-width: none;
            -ms-overflow-style: none;
            touch-action: pan-y;
            will-change: scroll-position;
            /* í„°ì¹˜ ì²˜ë¦¬ ìµœì í™” */
            user-select: none;
            -webkit-user-select: none;
        }
        
        .picker-values::-webkit-scrollbar {
            display: none;
        }
        
        .picker-item {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            scroll-snap-align: center;
            scroll-snap-stop: always;
            cursor: pointer;
            transition: color 0.3s;
            color: rgba(var(--text-color-rgb), 0.6);
        }
        
        .picker-item.selected {
            color: var(--text-color);
            font-weight: bold;
        }
        
        /* ëª¨ë“œ ì„ íƒ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ìˆ˜ì • */
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .mode-button {
            flex: 1;
            background-color: var(--input-bg-color);
            color: var(--text-color);
            border: none;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .mode-button:hover:not(:disabled) {
            background-color: var(--input-bg-hover);
        }
        
        .mode-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .mode-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .toggle-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .color-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.3s;
        }
        
        .color-option.selected {
            border-color: var(--text-color);
        }
        
        .color-option.red {
            background-color: #ff4d4d;
        }
        
        .color-option.green {
            background-color: #4caf50;
        }

        .sidebar-section.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        
        const useWakeLockManager = (isRunning, wakeLockRef) => {
            React.useEffect(() => {
                const requestWakeLock = async () => {
                    if ('wakeLock' in navigator && navigator.wakeLock.request) {
                        try {
                            if (!wakeLockRef.current) {
                                wakeLockRef.current = await navigator.wakeLock.request("screen");
                                console.log("âœ… Wake Lock ìš”ì²­ë¨");
                            }
                        } catch (err) {
                            console.error("âŒ Wake Lock ìš”ì²­ ì‹¤íŒ¨:", err);
                        }
                    }
                };

                const releaseWakeLock = async () => {
  if (wakeLockRef.current) {
    try {
      await wakeLockRef.current.release();
      wakeLockRef.current = null;
      console.log("ğŸ”“ Wake Lock í•´ì œë¨");
    } catch (err) {
      console.error("âŒ Wake Lock í•´ì œ ì‹¤íŒ¨:", err);
    }
  } else {
    console.log("ğŸ’¤ í•´ì œ ì‹œë„í–ˆì§€ë§Œ WakeLock ì—†ìŒ â†’ ê°•ì œ ë¦¬ì…‹ ì‹œë„");

    // âœ… ê°•ì œ Wake Lock ì¬ìš”ì²­ í›„ ì¦‰ì‹œ í•´ì œ (iOS ë²„ê·¸ ëŒ€ì‘)
    if ('wakeLock' in navigator && navigator.wakeLock.request) {
      try {
        const tempLock = await navigator.wakeLock.request("screen");
        await tempLock.release();
        console.log("ğŸ§¹ ê°•ì œ Wake Lock ë¦¬ì…‹ ì„±ê³µ");
      } catch (err) {
        console.warn("ğŸš« ê°•ì œ ë¦¬ì…‹ ì‹¤íŒ¨:", err);
      }
    }
  }
};

                const handleVisibilityChange = async () => {
                    if (document.visibilityState === 'visible') {
                        if (isRunning) {
                            await requestWakeLock();
                        } else {
                            await releaseWakeLock();
                        }
                    }
                };

                if (isRunning) {
                    requestWakeLock();
                } else {
                    releaseWakeLock();
                }

                document.addEventListener('visibilitychange', handleVisibilityChange);

                return () => {
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                    releaseWakeLock();
                };
            }, [isRunning]);
        };


        const App = () => {
            // ìƒíƒœ ê´€ë¦¬
            const [focusTime, setFocusTime] = React.useState(25);
            const [breakTime, setBreakTime] = React.useState(5);
            const [sets, setSets] = React.useState(4);
            const [currentSet, setCurrentSet] = React.useState(0);
            const [mode, setMode] = React.useState('focus');
            const [timeLeft, setTimeLeft] = React.useState(focusTime * 60);
            const [totalTime, setTotalTime] = React.useState(3600);
            const [isRunning, setIsRunning] = React.useState(false);
            const [isPaused, setIsPaused] = React.useState(false);
            const [isSidebarOpen, setIsSidebarOpen] = React.useState(false);
            const [isDarkMode, setIsDarkMode] = React.useState(true);
            const [timerColor, setTimerColor] = React.useState('red');
            const [showTicks, setShowTicks] = React.useState(true);
            const [showNumbers, setShowNumbers] = React.useState(true);
            const [showTimeDisplay, setShowTimeDisplay] = React.useState(false);
            const [soundEnabled, setSoundEnabled] = React.useState(false);
            const [vibrationEnabled, setVibrationEnabled] = React.useState(true);
            const [autoStart, setAutoStart] = React.useState(false);
            const [allSetsCompleted, setAllSetsCompleted] = React.useState(false); // ëª¨ë“  ì„¸íŠ¸ ì™„ë£Œ ì—¬ë¶€
            const [audioInitialized, setAudioInitialized] = React.useState(false);
            const wakeLockRef = React.useRef(null);
            useWakeLockManager(isRunning, wakeLockRef);
            
            // ì°¸ì¡° ìƒì„±
            const svgRef = React.useRef(null);
            const timePreviewRef = React.useRef(null);
            const focusAudioRef = React.useRef(null);
            const breakAudioRef = React.useRef(null);
            const focusPickerRef = React.useRef(null);
            const breakPickerRef = React.useRef(null);
            
            // ë‹¤í¬ ëª¨ë“œ ì„¤ì •
            React.useEffect(() => {
                if (isDarkMode) {
                    document.body.classList.add('dark-theme');
                    document.body.classList.remove('light-theme');
                } else {
                    document.body.classList.add('light-theme');
                    document.body.classList.remove('dark-theme');
                }
            }, [isDarkMode]);
            
            // ëª¨ë“œì— ë”°ë¥¸ ë°°ê²½ìƒ‰ ì„¤ì •
            React.useEffect(() => {
                if (mode === 'focus') {
                    document.body.classList.remove('break-mode');
                } else {
                    document.body.classList.add('break-mode');
                }
                
                // ëª¨ë“œ ë³€ê²½ ì‹œ íƒ€ì´ë¨¸ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                updateSVG();
            }, [mode]);

            // í”¼ì»¤ ê°’ì„ ì£¼ê¸°ì ìœ¼ë¡œ í™•ì¸í•˜ëŠ” useEffect ì¶”ê°€
            React.useEffect(() => {
                const checkPickerValues = () => {
                    if (focusPickerRef.current && !isRunning) {
                        const scrollTop = focusPickerRef.current.scrollTop;
                        const itemHeight = 40;
                        const index = Math.round(scrollTop / itemHeight);
                        
                        if (focusTime !== index) {
                            setFocusTime(index);
                            if (mode === 'focus') {
                                setTimeLeft(index * 60);
                                updateSVG();
                            }
                        }
                    }
                    
                    if (breakPickerRef.current && !isRunning) {
                        const scrollTop = breakPickerRef.current.scrollTop;
                        const itemHeight = 40;
                        const index = Math.round(scrollTop / itemHeight);
                        
                        if (breakTime !== index) {
                            setBreakTime(index);
                            if (mode === 'break') {
                                setTimeLeft(index * 60);
                                updateSVG();
                            }
                        }
                    }
                };
                
                // 200msë§ˆë‹¤ í”¼ì»¤ ê°’ì„ í™•ì¸
                const intervalId = setInterval(checkPickerValues, 200);
                
                return () => clearInterval(intervalId);
            }, [focusTime, breakTime, mode, isRunning]);

            // ì‹œê°„ í¬ë§·íŒ… í•¨ìˆ˜
            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            };
            
            // ì—…ë°ì´íŠ¸ í•¨ìˆ˜
                const updateSVG = React.useCallback(() => {
                    const svg = svgRef.current;
                    if (!svg) return;
                    
                    // SVG ë‚´ìš© ì´ˆê¸°í™”
                    while (svg.firstChild) {
                        svg.removeChild(svg.firstChild);
                    }
                    
                    const centerX = 300;
                    const centerY = 300;
                    const radius = 250;
                    
                    // ë©”ì¸ ëª¨ë“œì¼ ë•ŒëŠ” í…Œë§ˆì— ë”°ë¼, íœ´ì‹ ëª¨ë“œì¼ ë•ŒëŠ” ë°˜ì „
                    const isBreakMode = mode === 'break';
                    const shouldUseDarkTheme = (isDarkMode && !isBreakMode) || (!isDarkMode && isBreakMode);
                    
                    // ë°°ê²½ ì› ê·¸ë¦¬ê¸°
                    const backgroundCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    backgroundCircle.setAttribute("cx", centerX);
                    backgroundCircle.setAttribute("cy", centerY);
                    backgroundCircle.setAttribute("r", radius);
                    backgroundCircle.setAttribute("fill", shouldUseDarkTheme ? '#333' : '#e0e0e0');
                    backgroundCircle.style.pointerEvents = "none";
                    svg.appendChild(backgroundCircle);
                    
                    // ì§„í–‰ ìƒí™©ì— ë”°ë¥¸ ì›í˜• ì°¨íŠ¸ ê·¸ë¦¬ê¸°
                    if (timeLeft > 0 && totalTime > 0) { // 0ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ì˜¤ë¥˜ ë°©ì§€
                        let progress = timeLeft / totalTime;
                        if (progress === 1) {
                        progress = 0.9999; // ì™„ì „í•œ ì› ë§ê³  ê±°ì˜ ë‹¤ ì°¬ ì›ìœ¼ë¡œ
                        }
                    
                    // ì›í˜• ì°¨íŠ¸ì˜ ê°ë„ ê³„ì‚°
                    const startAngle = -Math.PI / 2; // 12ì‹œ ë°©í–¥ì—ì„œ ì‹œì‘
                    const endAngle = startAngle + (2 * Math.PI * progress); // ì§„í–‰ë„ì— ë”°ë¼ ê°ë„ ê³„ì‚°
                    
                    // SVG ê²½ë¡œ ìƒì„±
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    
                    // ì¤‘ì‹¬ì 
                    const x0 = centerX;
                    const y0 = centerY;
                    
                    // ì‹œì‘ì  (12ì‹œ ë°©í–¥)
                    const x1 = centerX;
                    const y1 = centerY - radius;
                    
                    // ì¢…ë£Œì  (ì§„í–‰ ê°ë„ì— ë”°ë¼ ê³„ì‚°)
                    const x2 = centerX + radius * Math.cos(endAngle);
                    const y2 = centerY + radius * Math.sin(endAngle);
                    
                    // í° í˜¸ì¸ì§€ ì‘ì€ í˜¸ì¸ì§€ ê²°ì • (180ë„ ì´ˆê³¼ ì—¬ë¶€)
                    const largeArcFlag = progress > 0.5 ? 1 : 0;
                    
                    // SVG ê²½ë¡œ ë°ì´í„° ìƒì„±
                    const d = [
                        `M ${x0} ${y0}`, // ì¤‘ì‹¬ì ìœ¼ë¡œ ì´ë™
                        `L ${x1} ${y1}`, // ì‹œì‘ì ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸°
                        `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`, // í˜¸ ê·¸ë¦¬ê¸°
                        'Z' // ê²½ë¡œ ë‹«ê¸° (ì¤‘ì‹¬ì ìœ¼ë¡œ ë‹¤ì‹œ ì—°ê²°)
                    ].join(' ');
                    
                    path.setAttribute("d", d);
                    path.setAttribute("fill", timerColor === 'red' ? '#ff4d4d' : '#4caf50');
                    path.style.pointerEvents = "none";
                    svg.appendChild(path);
                }
                
                // ëˆˆê¸ˆ ê·¸ë¦¬ê¸° (showTicksê°€ trueì¼ ë•Œë§Œ)
                if (showTicks) {
                    for (let i = 0; i < 60; i++) {
                        const angle = (i * 6 - 90) * (Math.PI / 180);
                        const inner = i % 5 === 0 ? radius + 4 : radius + 8;
                        const outer = i % 5 === 0 ? radius + 18 : radius + 12;
                        const x1 = centerX + inner * Math.cos(angle);
                        const y1 = centerY + inner * Math.sin(angle);
                        const x2 = centerX + outer * Math.cos(angle);
                        const y2 = centerY + outer * Math.sin(angle);
                        
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", x1);
                        line.setAttribute("y1", y1);
                        line.setAttribute("x2", x2);
                        line.setAttribute("y2", y2);
                        line.setAttribute("stroke", shouldUseDarkTheme ? '#fff' : '#333');
                        line.setAttribute("stroke-width", i % 5 === 0 ? 3 : 1);
                        line.style.pointerEvents = "none";
                        svg.appendChild(line);
                    }
                }
                
                // ìˆ«ì ê·¸ë¦¬ê¸° (showNumbersê°€ trueì¼ ë•Œë§Œ)
                if (showNumbers) {
                    for (let i = 0; i < 12; i++) {
                        const text = (i * 5).toString();
                        const angle = (i * 30 - 90) * (Math.PI / 180);
                        const tx = centerX + (radius + 40) * Math.cos(angle);
                        const ty = centerY + (radius + 40) * Math.sin(angle);
                        
                        const textElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        textElement.setAttribute("x", tx);
                        textElement.setAttribute("y", ty);
                        textElement.setAttribute("fill", shouldUseDarkTheme ? '#fff' : '#333');
                        textElement.setAttribute("font-size", "20px");
                        textElement.setAttribute("text-anchor", "middle");
                        textElement.setAttribute("dominant-baseline", "middle");
                        textElement.textContent = text;
                        textElement.style.pointerEvents = "none";
                        textElement.style.userSelect = "none";
                        textElement.style.webkitUserSelect = "none";
                        textElement.style.mozUserSelect = "none";
                        textElement.style.msUserSelect = "none";
                        svg.appendChild(textElement);
                    }
                }

            }, [timeLeft, totalTime, timerColor, showTicks, showNumbers, isPaused, isDarkMode, mode]);

            
            // ë“œë˜ê·¸ë¡œ ì‹œê°„ ì„¤ì •
            React.useEffect(() => {
                const svg = svgRef.current;
                const timePreview = timePreviewRef.current;
                if (!svg || !timePreview) return;
                let isDragging = false;
                
                const handleMouseDown = (e) => {
                    if (isRunning) return; // íƒ€ì´ë¨¸ ì‹¤í–‰ ì¤‘ì—ëŠ” ì„¤ì • ë¶ˆê°€
                    
                    const rect = svg.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // ì¤‘ì‹¬ì ê³¼ ê±°ë¦¬ ê³„ì‚°
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // ì°¨íŠ¸ ë‚´ë¶€ì¸ì§€ í™•ì¸ (ì› ì•ˆì— ìˆëŠ”ì§€)
                    // SVG viewBoxê°€ 600x600ì´ê³  ì› ë°˜ì§€ë¦„ì´ 220ì¸ ê²½ìš° ë¹„ìœ¨ ê³„ì‚°
                    const radius = (250 / 600) * rect.width;
                    
                    // ì› ì•ˆì— ìˆëŠ” ê²½ìš°ì—ë§Œ ë“œë˜ê·¸ ì‹œì‘
                    if (distance <= radius) {
                        isDragging = true;
                        updatePreviewFromCoords(x, y);
                    }
                };
                
                const handleMouseMove = (e) => {
                    if (!isDragging || isRunning) return;
                    
                    const rect = svg.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    updatePreviewFromCoords(x, y);
                };
                
                const handleMouseUp = () => {
                    if (!isDragging || isRunning) return;
                    
                    isDragging = false;
                    timePreview.style.display = 'none';
                };
                
                const handleTouchStart = (e) => {
                    if (isRunning) return;
                    e.preventDefault();
                    
                    const svg = svgRef.current;
                    const rect = svg.getBoundingClientRect();
                    const touch = e.touches[0];
                    
                    // í„°ì¹˜ ìœ„ì¹˜ ê³„ì‚°
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // ì¤‘ì‹¬ì ê³¼ ê±°ë¦¬ ê³„ì‚°
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // ì°¨íŠ¸ ë‚´ë¶€ì¸ì§€ í™•ì¸ (ì› ì•ˆì— ìˆëŠ”ì§€)
                    // SVG viewBoxê°€ 600x600ì´ê³  ì› ë°˜ì§€ë¦„ì´ 220ì¸ ê²½ìš° ë¹„ìœ¨ ê³„ì‚°
                    const radius = (250 / 600) * rect.width;
                    
                    // ì› ì•ˆì— ìˆëŠ” ê²½ìš°ì—ë§Œ ë“œë˜ê·¸ ì‹œì‘
                    if (distance <= radius) {
                        isDragging = true;
                        updatePreviewFromCoords(x, y);
                    }
                };

                const handleTouchMove = (e) => {
                    // ë“œë˜ê·¸ ì¤‘ì´ ì•„ë‹ˆê±°ë‚˜ íƒ€ì´ë¨¸ê°€ ì‹¤í–‰ ì¤‘ì´ë©´ ë¬´ì‹œ
                    if (!isDragging || isRunning) return;
                    
                    // ê¸°ë³¸ ë™ì‘ ë°©ì§€ (ìŠ¤í¬ë¡¤ ë“±)
                    e.preventDefault();
                    
                    const svg = svgRef.current;
                    const rect = svg.getBoundingClientRect();
                    const touch = e.touches[0];
                    
                    // í„°ì¹˜ ìœ„ì¹˜ ê³„ì‚°
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // ì¢Œí‘œ ì—…ë°ì´íŠ¸ (ì› ì•ˆ/ë°– ìƒê´€ì—†ì´ ì§„í–‰)
                    updatePreviewFromCoords(x, y);
                };

                const handleTouchEnd = (e) => {
                    if (!isDragging || isRunning) return;
                    
                    e.preventDefault();
                    isDragging = false;
                    timePreview.style.display = 'none';
                };
                
                // ì¢Œí‘œë¡œë¶€í„° ì‹œê°„ ì„¤ì • ë° ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
                const updatePreviewFromCoords = (x, y) => {
                    if (!svgRef.current || isNaN(x) || isNaN(y)) return;

                    const svg = svgRef.current;
                    const rect = svg.getBoundingClientRect();

                    const centerX = svg.clientWidth / 2;
                    const centerY = svg.clientHeight / 2;
                    const dx = x - centerX;
                    const dy = y - centerY;

                    let angle = Math.atan2(dy, dx);
                    if (angle < -0.5 * Math.PI) angle += 2 * Math.PI;

                    const percent = (angle + 0.5 * Math.PI) / (2 * Math.PI);
                    const mins = Math.max(0, Math.min(60, Math.round(percent * 60)));
                    const newTimeInSeconds = mins * 60;

                    // ë¯¸ë¦¬ë³´ê¸° ì‹œê°„ í‘œì‹œ
                    const timePreview = timePreviewRef.current;
                    if (timePreview) {
                        timePreview.textContent = `${mins.toString().padStart(2, '0')}:00`;
                        timePreview.style.display = 'block';
                    }

                    setTimeLeft(newTimeInSeconds);
                    if (mode === 'focus') setFocusTime(mins);
                    else setBreakTime(mins);

                    const children = svg.childNodes;
                    for (let i = children.length - 1; i >= 0; i--) {
                        const el = children[i];
                        const tag = el.tagName ? el.tagName.toLowerCase() : "";
                        if (tag !== "line" && tag !== "text") {
                            svg.removeChild(el);
                        }
                    }

                    // ë°°ê²½ ì› ê·¸ë¦¬ê¸°
                    const centerXSVG = 300;
                    const centerYSVG = 300;
                    const radius = 250;

                    const isBreakMode = mode === 'break';
                    const shouldUseDarkTheme = (isDarkMode && !isBreakMode) || (!isDarkMode && isBreakMode);

                    const backgroundCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    backgroundCircle.setAttribute("cx", centerXSVG);
                    backgroundCircle.setAttribute("cy", centerYSVG);
                    backgroundCircle.setAttribute("r", radius);
                    backgroundCircle.setAttribute("fill", shouldUseDarkTheme ? '#333' : '#e0e0e0');
                    backgroundCircle.style.pointerEvents = "none";
                    svg.appendChild(backgroundCircle);

                    // ì§„í–‰ë¥  path ê·¸ë¦¬ê¸°
                    let timeRatio = newTimeInSeconds / 3600;
                    if (Math.round(newTimeInSeconds) === 3600) {
                        timeRatio = 0.9999; // full circle ë¬¸ì œ ë°©ì§€
                    }

                    const startAngle = -Math.PI / 2;
                    const endAngle = startAngle + (2 * Math.PI * timeRatio);

                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");

                    const x0 = centerXSVG;
                    const y0 = centerYSVG;
                    const x1 = centerXSVG;
                    const y1 = centerYSVG - radius;
                    const x2 = centerXSVG + radius * Math.cos(endAngle);
                    const y2 = centerYSVG + radius * Math.sin(endAngle);
                    const largeArcFlag = timeRatio > 0.5 ? 1 : 0;

                    const d = [
                        `M ${x0} ${y0}`,
                        `L ${x1} ${y1}`,
                        `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`,
                        'Z'
                    ].join(' ');

                    path.setAttribute("d", d);
                    path.setAttribute("fill", timerColor === 'red' ? '#ff4d4d' : '#4caf50');
                    path.style.pointerEvents = "none";
                    svg.appendChild(path);
                };


                
                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                svg.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                svg.addEventListener('touchstart', handleTouchStart, { passive: false });
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd, { passive: false });
                
                return () => {
                    svg.removeEventListener('mousedown', handleMouseDown);
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    
                    svg.removeEventListener('touchstart', handleTouchStart);
                    document.removeEventListener('touchmove', handleTouchMove);
                    document.removeEventListener('touchend', handleTouchEnd);
                };
            }, [isRunning, mode, isDarkMode, showTicks, showNumbers, timerColor]);
            
            // íœ  í”¼ì»¤ ì´ˆê¸°í™”
            React.useEffect(() => {
                if (focusPickerRef.current) {
                const scrollPos = focusTime * 40;
                focusPickerRef.current.scrollTop = scrollPos;
                }
                 if (breakPickerRef.current) {
                const scrollPos = breakTime * 40;
                breakPickerRef.current.scrollTop = scrollPos;
                }
            }, [focusTime, breakTime]);
            
            // íœ  í”¼ì»¤ ì•„ì´í…œ ë Œë”ë§
            const renderPickerItems = (max, value, onChange) => {
                const items = [];
                for (let i = 0; i <= max; i++) { // 0ë¶€í„° maxê¹Œì§€ (60 í¬í•¨)
                    items.push(
                        <div 
                            key={i} 
                            className={`picker-item ${i === value ? 'selected' : ''}`}
                            onClick={() => {
                                if (!isRunning || isPaused) {
                                    onChange(i);
                                    if ((mode === 'focus' && onChange === setFocusTime) || 
                                        (mode === 'break' && onChange === setBreakTime)) {
                                        setTimeLeft(i * 60);
                                        // ì°¨íŠ¸ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                                        updateChartDirectly(i);
                                    }
                                }
                            }}
                        >
                            {i}
                        </div>
                    );
                }
                return items;
            };
            
            // ì˜¤ë””ì˜¤ ìš”ì†Œ ìƒì„±
            React.useEffect(() => {
                // ì•Œë¦¼ìŒ
                const focusAudio = new Audio("https://ryan-g00.github.io/pomodoro/dingdong.mp3");
                const breakAudio = new Audio("https://ryan-g00.github.io/pomodoro/beep.mp3");
                
                focusAudioRef.current = focusAudio;
                breakAudioRef.current = breakAudio;
                
                return () => {
                    focusAudio.pause();
                    breakAudio.pause();
                };
            }, []);
            
            // íƒ€ì´ë¨¸ ì‹œì‘
            const startTimer = async () => {
                if ('wakeLock' in navigator && navigator.wakeLock.request) {
                try {
                    if (wakeLockRef.current) {
                        await wakeLockRef.current.release();
                        wakeLockRef.current = null;
                    }
                    wakeLockRef.current = await navigator.wakeLock.request('screen');
                    console.log("âœ… Wake Lock ìš”ì²­ ì„±ê³µ");
                } catch (err) {
                    console.warn("âŒ Wake Lock ìš”ì²­ ì‹¤íŒ¨:", err);
                }
            }

            
            // âœ… ì‚¬íŒŒë¦¬ìš© ì˜¤ë””ì˜¤ ì¬ìƒ ê¶Œí•œ í™•ë³´ (ë¬´ìŒ ì¬ìƒ)
            if (!audioInitialized && focusAudioRef.current && breakAudioRef.current) {
                try {
                // 0.1ë¡œ í–ˆë”ë‹ˆ ê°„ê°„íˆ ì§§ê²Œ ë“¤ë¦¬ëŠ” í˜„ìƒ ë°œìƒí•¨. 0.001ë¡œ ë³€ê²½
                focusAudioRef.current.volume = 0.001;
                focusAudioRef.current.currentTime = 0;
                const playPromise = focusAudioRef.current.play();
                focusAudioRef.current.pause();

                playPromise
                    .then(() => {
                        focusAudioRef.current.currentTime = 0;
                        focusAudioRef.current.volume = 1; // ì›ë˜ëŒ€ë¡œ ë³µêµ¬
                    })
                    .catch(() => {});

                // 0.1ë¡œ í–ˆë”ë‹ˆ ê°„ê°„íˆ ì§§ê²Œ ë“¤ë¦¬ëŠ” í˜„ìƒ ë°œìƒí•¨. 0.001ë¡œ ë³€ê²½    
                breakAudioRef.current.volume = 0.001;
                breakAudioRef.current.currentTime = 0;
                const breakPlayPromise = breakAudioRef.current.play();
                breakAudioRef.current.pause(); // ì¦‰ì‹œ ì¤‘ì§€ ì‹œë„
                
                breakPlayPromise
                    .then(() => {
                        breakAudioRef.current.currentTime = 0;
                        breakAudioRef.current.volume = 1; // ì›ë˜ëŒ€ë¡œ ë³µêµ¬
                    })
                    .catch(() => {});
                setAudioInitialized(true);
            } catch (err) {
                console.warn("Audio warm-up failed:", err);
            }
        }

            if (allSetsCompleted) {
                // ì„¸íŠ¸ê°€ ëª¨ë‘ ëë‚œ ê²½ìš°: íƒ€ì´ë¨¸ì™€ ì„¸íŠ¸ ì´ˆê¸°í™”
                const newTime = focusTime * 60;
                setTimeLeft(newTime);
                setTotalTime(newTime);
                setCurrentSet(0);
                setMode('focus');
                setAllSetsCompleted(false);
    }

            // íƒ€ì´ë¨¸ ì‹œì‘
            if (!isRunning) {
                setIsRunning(true);
                setIsPaused(false);
            }
            };


            // íƒ€ì´ë¨¸ ì‹œì‘ ì§ì „
            const handleUserInteraction = () => {
            // í•œ ë²ˆ ì¬ìƒ í›„ ë°”ë¡œ ì¤‘ë‹¨ ì‚¬íŒŒë¦¬ ì†Œë¦¬ ì¬ìƒ ë¬¸ì œ í•´ê²° ìœ„í•´..
            if (focusAudioRef.current) {
                focusAudioRef.current.volume = 0.01;
                focusAudioRef.current.play().then(() => {
                focusAudioRef.current.pause();
                focusAudioRef.current.currentTime = 0;
                }).catch(() => {});
            }
            };
            
            // íƒ€ì´ë¨¸ ì¼ì‹œì •ì§€
            const pauseTimer = async () => {
                setIsRunning(false);
                setIsPaused(true);

                // íƒ€ì´ë¨¸ ë©ˆì¶”ë©´ Wake Lock í•´ì œ
                if (wakeLockRef.current) {
                    try {
                        await wakeLockRef.current.release();
                        wakeLockRef.current = null;
                        console.log("ğŸ”“ Wake Lock í•´ì œë¨");
                    } catch (err) {
                        console.error("ğŸ”´ Wake Lock í•´ì œ ì‹¤íŒ¨:", err);
                    }
                }
            };
            
            // íƒ€ì´ë¨¸ ë¦¬ì…‹
            const resetTimer = () => {
                setIsRunning(false);
                setIsPaused(false);
                setTimeLeft(mode === 'focus' ? focusTime * 60 : breakTime * 60);
                setAllSetsCompleted(false); // íƒ€ì´ë¨¸ ë¦¬ì…‹ ì‹œ ì„¸íŠ¸ ì™„ë£Œ ìƒíƒœ ì´ˆê¸°í™”
                updateSVG();
            };
            
            // ì„¸íŠ¸ ì¦ê°€/ê°ì†Œ í•¸ë“¤ëŸ¬
            const handleDecreaseSets = () => {
                if (sets > 1 && !isRunning) {
                    setSets(prev => prev - 1);
                }
            };
            
            const handleIncreaseSets = () => {
                if (sets < 10 && !isRunning) {
                    setSets(prev => prev + 1);
                }
            };
            
            // íƒ€ì´ë¨¸ ì• ë‹ˆë©”ì´ì…˜
            React.useEffect(() => {
                let intervalId = null;
                
                if (isRunning) {
                    const startTime = Date.now();
                    const initialTimeLeft = timeLeft;
                    
                    intervalId = setInterval(() => {
                        const elapsedSeconds = (Date.now() - startTime) / 1000;
                        const newTimeLeft = Math.max(0, initialTimeLeft - elapsedSeconds);
                        
                        setTimeLeft(newTimeLeft);
                        updateSVG();
                        
                        if (newTimeLeft <= 0) {
                            clearInterval(intervalId);
                            setIsRunning(false);
                            
                            // íƒ€ì´ë¨¸ ì¢…ë£Œ ì‹œ ì•Œë¦¼
                            if (soundEnabled) {
                                if (mode === 'focus') {
                                    focusAudioRef.current.play();
                                } else {
                                    breakAudioRef.current.play();
                                }
                            }
                            
                            if (vibrationEnabled && navigator.vibrate) {
                                navigator.vibrate([200, 100, 200]);
                            }
                            
                            // ëª¨ë“œ ì „í™˜
                            if (mode === 'focus') {
                                // ì§‘ì¤‘ ëª¨ë“œê°€ ëë‚˜ë©´ ì„¸íŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
                                if (currentSet < sets) {
                                    setCurrentSet(prev => prev + 1);
                                } else {
                                    setAllSetsCompleted(true); // ëª¨ë“  ì„¸íŠ¸ ì™„ë£Œ í‘œì‹œ
                                }

                                setMode('break');
                                setTimeLeft(breakTime * 60);
                                
                                // ìë™ ì‹œì‘ ê¸°ëŠ¥
                                if (autoStart && !allSetsCompleted) {
                                    setTimeout(() => {
                                        setIsRunning(true);
                                    }, 500);
                                }
                            } else {
                                // íœ´ì‹ ëª¨ë“œê°€ ëë‚œ í›„
                                if (currentSet < sets) {
                                    // ì•„ì§ ì„¸íŠ¸ê°€ ë‚¨ì•„ìˆìœ¼ë©´
                                    setMode('focus');
                                    setTimeLeft(focusTime * 60);
                                    
                                    // ìë™ ì‹œì‘ ê¸°ëŠ¥
                                    if (autoStart && !allSetsCompleted) {
                                        setTimeout(() => {
                                            setIsRunning(true);
                                        }, 500);
                                    }
                                } else {
                                    // ëª¨ë“  ì„¸íŠ¸ê°€ ì™„ë£Œë˜ë©´
                                    setMode('focus');
                                    setTimeLeft(focusTime * 60);
                                    setAllSetsCompleted(true); // ëª¨ë“  ì„¸íŠ¸ ì™„ë£Œ í‘œì‹œ
                                }
                            }
                        }
                    }, 100); // 100msë§ˆë‹¤ ì—…ë°ì´íŠ¸
                } else {
                    updateSVG();
                }
                
                return () => {
                    if (intervalId) {
                        clearInterval(intervalId);
                    }
                };
            }, [isRunning, mode, focusTime, breakTime, sets, currentSet, soundEnabled, vibrationEnabled, totalTime, timeLeft, autoStart, allSetsCompleted, updateSVG]);
            
            // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ íƒ€ì´ë¨¸ ê·¸ë¦¬ê¸°
            React.useEffect(() => {
                if (svgRef.current) {
                    // SVG ìš”ì†Œ ìì²´ì—ëŠ” ì´ë²¤íŠ¸ë¥¼ ë°›ë„ë¡ ì„¤ì •
                    svgRef.current.style.pointerEvents = "auto";
                }
                setTotalTime(3600);
                updateSVG();
            }, [updateSVG]);
            
            // í† ê¸€ ìŠ¤ìœ„ì¹˜ ì»´í¬ë„ŒíŠ¸
            const ToggleSwitch = ({ label, checked, onChange, id, disabled }) => {
                return (
                    <div className="toggle-container">
                        <span id={`${id}-label`}>{label}</span>
                        <label className="toggle-switch" htmlFor={id}>
                            <input 
                                id={id}
                                name={id}
                                type="checkbox" 
                                checked={checked} 
                                onChange={onChange}
                                aria-labelledby={`${id}-label`}
                                disabled={disabled}
                            />
                            <span className="toggle-slider"></span>
                        </label>
                    </div>
                );
            };
            
            return (
                <div className="app-container">
                    <button 
                        className="menu-button"
                        onClick={() => setIsSidebarOpen(true)}
                        aria-label="ì„¤ì • ë©”ë‰´ ì—´ê¸°"
                        id="menu-button"
                    >
                        â˜°
                    </button>
                    
                    <div 
                        className={`overlay ${isSidebarOpen ? 'active' : ''}`}
                        onClick={() => setIsSidebarOpen(false)}
                        aria-hidden="true"
                    ></div>
                    
                    <div className={`sidebar ${isSidebarOpen ? 'open' : ''}`} aria-label="ì„¤ì • ë©”ë‰´">
                        <div className="sidebar-header">
                            <h1 id="settings-header">ì„¤ì •</h1>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="time-settings-header">ì‹œê°„ ì„¤ì •</h2>
                            <div className="time-pickers">
                                <div className="time-picker">
                                    <label className="time-picker-label" htmlFor="focus-time-picker">ì§‘ì¤‘ ì‹œê°„ (ë¶„)</label>
                                    <div className="picker-container">
                                        <div className="picker-highlight"></div>
                                        <div 
                                            id="focus-time-picker"
                                            className="picker-values" 
                                            ref={focusPickerRef}
                                            onTouchStart={(e) => e.stopPropagation()}
                                        >
                                            {renderPickerItems(60, focusTime, (value) => {
                                                if (!isRunning) {
                                                    setFocusTime(value);
                                                    if (mode === 'focus') {
                                                        setTimeLeft(value * 60);
                                                        setTotalTime(value * 60);
                                                        updateSVG();
                                                    }
                                                }
                                            })}
                                        </div>
                                    </div>
                                </div>
                                <div className="time-picker">
                                    <label className="time-picker-label" htmlFor="break-time-picker">íœ´ì‹ ì‹œê°„ (ë¶„)</label>
                                    <div className="picker-container">
                                        <div className="picker-highlight"></div>
                                        <div 
                                            id="break-time-picker"
                                            className="picker-values" 
                                            ref={breakPickerRef}
                                            onTouchStart={(e) => e.stopPropagation()}
                                        >
                                            {renderPickerItems(60, breakTime, (value) => {
                                                if (!isRunning) {
                                                    setBreakTime(value);
                                                    if (mode === 'break') {
                                                        setTimeLeft(value * 60);
                                                        setTotalTime(value * 60);
                                                        updateSVG();
                                                    }
                                                }
                                            })}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning? 'disabled' : ''}`}>
                            <h2 id="mode-selection-header">ëª¨ë“œ ì„ íƒ</h2>
                            <div className="mode-selector" role="group" aria-labelledby="mode-selection-header">
                                <button 
                                    id="focus-mode-button"
                                    name="focus-mode"
                                    className={`mode-button ${mode === 'focus' ? 'active' : ''}`}
                                    onClick={() => {
                                        if (!isRunning) {
                                            setMode('focus');
                                            setTimeLeft(focusTime * 60);
                                            updateSVG();
                                        }
                                    }}
                                    disabled={isRunning}
                                    aria-pressed={mode === 'focus'}
                                >
                                    ì§‘ì¤‘
                                </button>
                                <button 
                                    id="break-mode-button"
                                    name="break-mode"
                                    className={`mode-button ${mode === 'break' ? 'active' : ''}`}
                                    onClick={() => {
                                        if (!isRunning) {
                                            setMode('break');
                                            setTimeLeft(breakTime * 60);
                                            updateSVG();
                                        }
                                    }}
                                    disabled={isRunning}
                                    aria-pressed={mode === 'break'}
                                >
                                    íœ´ì‹
                                </button>
                            </div>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="sets-setting-header">ì„¸íŠ¸ ì„¤ì •</h2>
                            <div className="sets-container">
                                <label htmlFor="sets-counter" className="sets-label">ë°˜ë³µ íšŸìˆ˜</label>
                                <div id="sets-counter" className="sets-counter">
                                    <button 
                                        className="sets-button" 
                                         onClick={handleDecreaseSets}
                                         disabled={sets <= 1 || isRunning}
                                        aria-label="ë°˜ë³µ íšŸìˆ˜ ê°ì†Œ"
                                    >
                                         -
                                    </button>
                                    <div className="sets-value" aria-live="polite">
                                        {sets}
                                    </div>
                                    <button 
                                        className="sets-button"
                                        onClick={handleIncreaseSets}
                                        disabled={sets >= 10 || isRunning || isPaused}
                                        aria-label="ë°˜ë³µ íšŸìˆ˜ ì¦ê°€"
                                    >
                                        +
                                    </button>
                                </div>
                            </div>
                            <div className="toggle-container" style={{ marginTop: '10px' }}>
                                <span id="auto-start-label">ìë™ ì‹œì‘</span>
                                <label className="toggle-switch" htmlFor="auto-start-toggle">
                                    <input 
                                        id="auto-start-toggle"
                                        name="auto-start-toggle"
                                        type="checkbox" 
                                        checked={autoStart} 
                                        onChange={() => {
                                            if (!isRunning) {
                                                setAutoStart(prev => !prev);
                                            }
                                        }}
                                        disabled={isRunning}
                                        aria-labelledby="auto-start-label"
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="theme-setting-header">í…Œë§ˆ ì„¤ì •</h2>
                            <ToggleSwitch 
                                id="dark-mode-toggle"
                                label="ë‹¤í¬ ëª¨ë“œ" 
                                checked={isDarkMode} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setIsDarkMode(prev => !prev);
                                    }
                                }}
                                disabled={isRunning}
                            />
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="color-selection-header">ì°¨íŠ¸ ìƒ‰ìƒ ì„ íƒ</h2>
                            <div className="color-options" role="radiogroup" aria-labelledby="color-selection-header">
                                <div 
                                    className={`color-option red ${timerColor === 'red' ? 'selected' : ''}`}
                                    onClick={() => {
                                        if (!isRunning) {
                                            setTimerColor('red');
                                            updateSVG();
                                        }
                                    }}
                                    role="radio"
                                    aria-checked={timerColor === 'red'}
                                    tabIndex={timerColor === 'red' ? 0 : -1}
                                    aria-label="ë¹¨ê°„ìƒ‰"
                                    id="red-color-option"
                                ></div>
                                <div 
                                    className={`color-option green ${timerColor === 'green' ? 'selected' : ''}`}
                                    onClick={() => {
                                        if (!isRunning) {
                                            setTimerColor('green');
                                            updateSVG();
                                        }
                                    }}
                                    role="radio"
                                    aria-checked={timerColor === 'green'}
                                    tabIndex={timerColor === 'green' ? 0 : -1}
                                    aria-label="ì´ˆë¡ìƒ‰"
                                    id="green-color-option"
                                ></div>
                            </div>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="notifications-header">ì•Œë¦¼ ì„¤ì •</h2>
                            <ToggleSwitch 
                                id="sound-toggle"
                                label="ì†Œë¦¬ ì•Œë¦¼" 
                                checked={soundEnabled} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setSoundEnabled(prev => !prev);
                                    }
                                }}
                                disabled={isRunning}
                            />
                            <ToggleSwitch 
                                id="vibration-toggle"
                                label="ì§„ë™ ì•Œë¦¼" 
                                checked={vibrationEnabled} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setVibrationEnabled(prev => !prev);
                                    }
                                }}
                                disabled={isRunning}
                            />
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="display-settings-header">í‘œì‹œ ì„¤ì •</h2>
                            <ToggleSwitch 
                                id="ticks-toggle"
                                label="ëˆˆê¸ˆ í‘œì‹œ" 
                                checked={showTicks} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setShowTicks(prev => !prev);
                                        updateSVG();
                                    }
                                }}
                                disabled={isRunning}
                            />
                            <ToggleSwitch 
                                id="numbers-toggle"
                                label="ì‹œê°„ ìˆ«ì í‘œì‹œ" 
                                checked={showNumbers} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setShowNumbers(prev => !prev);
                                        updateSVG();
                                    }
                                }}
                                disabled={isRunning}
                            />
                            <ToggleSwitch 
                                id="time-display-toggle"
                                label="ì‹¤ì‹œê°„ ì‹œê°„ í‘œì‹œ" 
                                checked={showTimeDisplay} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setShowTimeDisplay(prev => !prev);
                                    }
                                }}
                                disabled={isRunning}
                            />
                        </div>
                    </div>
                    
                    <div className="timer-container" style={{ touchAction: 'none' }}>
                        <div className="timer-display">
                            <svg 
                                ref={svgRef}
                                className="timer-svg"
                                viewBox="0 0 600 600"
                                xmlns="http://www.w3.org/2000/svg"
                                aria-label="ë½€ëª¨ë„ë¡œ íƒ€ì´ë¨¸ ì‹œê°í™”"
                                role="img"
                                style={{ touchAction: 'none' }}
                            ></svg>
                            
                            <div 
                                ref={timePreviewRef}
                                className="time-preview"
                                aria-live="polite"
                                aria-atomic="true"
                            ></div>
                            
                            {showTimeDisplay && (
                                <div 
                                    className="timer-time"
                                    aria-live="polite"
                                    aria-atomic="true"
                                    role="timer"
                                    aria-label={`í˜„ì¬ ì‹œê°„: ${formatTime(timeLeft)}`}
                                >
                                    {formatTime(timeLeft)}
                                </div>
                            )}
                            
                            <div
                            className="set-display"
                            aria-live="polite"
                            aria-atomic="true">
                                {currentSet}/{sets} ì„¸íŠ¸ - {mode === 'focus' ? 'ì§‘ì¤‘' : 'íœ´ì‹'}
                            </div>
                        </div>

                        {isPaused && !isRunning && (
                                <div
                                style={{
                                    position: 'absolute',
                                    top: '300px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: '20px',
                                    color: isDarkMode ? '#fff' : '#333',
                                }}
                                >
                                ì¼ì‹œì •ì§€ë¨
                                </div>
                            )}

                       <div className="timer-actions">
                        <button 
                            className="timer-button" 
                            onClick={isRunning ? pauseTimer : startTimer}
                            aria-label={isRunning ? "ì¼ì‹œì •ì§€" : "ì‹œì‘"}
                            id="play-pause-button"
                        >
                            {isRunning ? 'âˆ¥' : 'â–¶'}
                        </button>

                        {isPaused && (
                        <button className="timer-button" onClick={resetTimer}>â†º</button>
                        )}

                        </div>
                    </div>
                </div>
            );
        };
        // ì•± ë Œë”ë§ ê¸°ëª¨ë§~
        const rootElement = document.getElementById('root');
        ReactDOM.render(React.createElement(App), rootElement);
    </script>
</body>
</html>