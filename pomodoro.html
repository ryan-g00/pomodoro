<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>굴러라굴러정해량</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>

    <link rel="icon" href="A_digital_vector_graphic_displays_a_minimalist,_fl.png" type="image/png">
    <link rel="apple-touch-icon" href="A_digital_vector_graphic_displays_a_minimalist,_fl.png">
    <link rel="manifest" href="manifest.json">

    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --text-color: #ffffff;
            --text-color-rgb: 255, 255, 255;
            --primary-color: #ff4d4d;
            --secondary-color: #4caf50;
            --accent-color: #2196f3;
            --border-color: #333;
            --input-bg-color: #2a2a2a;
            --input-bg-hover: #3a3a3a;
            --highlight-color: rgba(255, 255, 255, 0.1);
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.5s, color 0.5s;
        }
        
        body.light-theme {
            --bg-color: #f5f5f7;
            --surface-color: #ffffff;
            --text-color: #1d1d1f;
            --text-color-rgb: 29, 29, 31;
            --border-color: #d1d1d6;
            --input-bg-color: #e5e5e5;
            --input-bg-hover: #d5d5d5;
            --highlight-color: rgba(0, 0, 0, 0.05);
        }
        
        /* 휴식 모드일 때 적용할 스타일 - 색상 반전 */
        body.break-mode {
            transition: background-color 0.5s, color 0.5s;
        }
        
        body.dark-theme.break-mode {
            background-color: #f5f5f7;
            color: #1d1d1f;
        }
        
        body.light-theme.break-mode {
            background-color: #121212;
            color: #ffffff;
        }
        
        /* 휴식 모드일 때 UI 요소 색상 반전 */
        body.break-mode .timer-time,
        body.break-mode .set-display,
        body.break-mode .timer-button {
            color: inherit;
        }
        
        .app-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1; /* 필요에 따라 z-index 설정 */
            touch-action: none;
        }
        
        .timer-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: relative;
            touch-action: none;
        }
        .timer-display {
            position: relative;
            width: 95vmin;
            height: 95vmin;
            max-width: 700px;
            max-height: 700px;
            margin: 0 auto;
            touch-action: none;
        }
        
        .timer-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .timer-time {
            position: fixed;
            bottom: 70px;
            left: 30px;
            font-size: 45px;
            font-weight: 600;
            color: var(--text-color);
            z-index: 10;
            transition: color 0.3s;
        }
        
        .time-preview {
            position: fixed; 
            bottom: 70px;
            left: 30px;
            font-size: 45px;
            font-weight: 600;
            color: var(--text-color);
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            display: none;
            pointer-events: none;
            z-index: 11;
            transition: color 0.3s;
        }
        
        .set-display {
            position: fixed;
            bottom: 40px;
            left: 30px;
            font-size: 25px;
            font-weight: 500;
            color: var(--text-color);
            transition: color 0.3s;
        }
        
        body.dark-theme.break-mode .timer-time,
        body.dark-theme.break-mode .time-preview,
        body.dark-theme.break-mode .set-display {
            color: #1d1d1f;
        }
        
        body.light-theme.break-mode .timer-time,
        body.light-theme.break-mode .time-preview,
        body.light-theme.break-mode .set-display {
            color: #ffffff;
        }

        .sets-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }
        
        .sets-label {
            flex: 1;
        }
        
        .sets-counter {
            display: flex;
            align-items: center;
            background-color: var(--input-bg-color);
            border-radius: 4px;
            overflow: hidden;
            transition: background-color 0.3s;
        }
        
        .sets-button {
            width: 36px;
            height: 36px;
            background-color: var(--input-bg-color);
            border: none;
            color: var(--text-color);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .sets-button:hover:not(:disabled) {
            background-color: var(--input-bg-hover);
        }
        
        .sets-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .sets-value {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: var(--text-color);
            transition: color 0.3s;
        }
        
        .timer-actions {
            position: fixed;
            bottom: 40px;
            right: 30px;
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        
        .timer-button {
            background: none;
            color: var(--text-color);
            border: none;
            width: 40px;
            height: 40px;
            font-size: 30px;
            cursor: pointer;
            transition: opacity 0.3s, color 0.3s;
            opacity: 0.8;
            padding: 0;
        }
        
        /* 휴식 모드일 때 버튼 색상 반전 */
        body.dark-theme.break-mode .timer-button {
            color: #1d1d1f;
        }
        
        body.light-theme.break-mode .timer-button {
            color: #ffffff;
        }
        .timer-button:hover {
            opacity: 1;
            color: var(--text-color);
        }
        
        .menu-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 24px;
            cursor: pointer;
            z-index: 1000;
            transition: color 0.3s;
        }
        
        /* 휴식 모드일 때 메뉴 버튼 색상 반전 */
        body.dark-theme.break-mode .menu-button {
            color: #1d1d1f;
        }
        
        body.light-theme.break-mode .menu-button {
            color: #ffffff;
        }
        
        .sidebar {
            position: fixed;
            top: 0;
            left: -300px;
            width: 300px;
            height: 100%;
            background-color: var(--surface-color);
            transition: left 0.3s, background-color 0.3s;
            overflow-y: auto;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            color: var(--text-color);
        }
        
        .sidebar.open {
            left: 0;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 999;
        }
        
        .overlay.active {
            display: block;
        }
        
        .sidebar-header {
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
            color: var(--text-color);
            font-weight: bold;
        }
        
        .sidebar-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .sidebar-section:last-child {
            border-bottom: none;
        }
        
        /* 시간 픽커 스타일 추가 */
        .time-pickers {
            display: flex;
            gap: 10px;
        }
        
        .time-picker {
            flex: 1;
        }
        
        .time-picker-label {
            display: block;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .picker-container {
            position: relative;
            height: 120px;
            overflow: hidden;
            border-radius: 8px;
            background-color: var(--input-bg-color);
            transition: background-color 0.3s;
        }
        
        .picker-highlight {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 40px;
            transform: translateY(-50%);
            background-color: var(--highlight-color);
            pointer-events: none;
            transition: background-color 0.3s;
        }
        
        .picker-values {
            height: 100%;
            box-sizing: border-box;
            overflow-y: auto;
            scroll-snap-type: y mandatory;
            padding: 40px 0;
            -webkit-overflow-scrolling: touch;
            transform: translateZ(0);
            scrollbar-width: none;
            -ms-overflow-style: none;
            touch-action: pan-y;
            will-change: scroll-position;
            /* 터치 처리 최적화 */
            user-select: none;
            -webkit-user-select: none;
        }
        
        .picker-values::-webkit-scrollbar {
            display: none;
        }
        
        .picker-item {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            scroll-snap-align: center;
            scroll-snap-stop: always;
            cursor: pointer;
            transition: color 0.3s;
            color: rgba(var(--text-color-rgb), 0.6);
        }
        
        .picker-item.selected {
            color: var(--text-color);
            font-weight: bold;
        }
        
        /* 모드 선택 버튼 스타일 수정 */
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .mode-button {
            flex: 1;
            background-color: var(--input-bg-color);
            color: var(--text-color);
            border: none;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .mode-button:hover:not(:disabled) {
            background-color: var(--input-bg-hover);
        }
        
        .mode-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .mode-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .toggle-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .color-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.3s;
        }
        
        .color-option.selected {
            border-color: var(--text-color);
        }
        
        .color-option.red {
            background-color: #ff4d4d;
        }
        
        .color-option.green {
            background-color: #4caf50;
        }

        .sidebar-section.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const App = () => {
            // 상태 관리
            const [focusTime, setFocusTime] = React.useState(25);
            const [breakTime, setBreakTime] = React.useState(5);
            const [sets, setSets] = React.useState(4);
            const [currentSet, setCurrentSet] = React.useState(0);
            const [mode, setMode] = React.useState('focus');
            const [timeLeft, setTimeLeft] = React.useState(focusTime * 60);
            const [totalTime, setTotalTime] = React.useState(3600);
            const [isRunning, setIsRunning] = React.useState(false);
            const [isPaused, setIsPaused] = React.useState(false);
            const [isSidebarOpen, setIsSidebarOpen] = React.useState(false);
            const [isDarkMode, setIsDarkMode] = React.useState(true);
            const [timerColor, setTimerColor] = React.useState('red');
            const [showTicks, setShowTicks] = React.useState(true);
            const [showNumbers, setShowNumbers] = React.useState(true);
            const [showTimeDisplay, setShowTimeDisplay] = React.useState(true);
            const [soundEnabled, setSoundEnabled] = React.useState(true);
            const [vibrationEnabled, setVibrationEnabled] = React.useState(true);
            const [autoStart, setAutoStart] = React.useState(false);
            const [allSetsCompleted, setAllSetsCompleted] = React.useState(false); // 모든 세트 완료 여부
            let wakeLock = null;
            
            // 참조 생성
            const svgRef = React.useRef(null);
            const timePreviewRef = React.useRef(null);
            const focusAudioRef = React.useRef(null);
            const breakAudioRef = React.useRef(null);
            const focusPickerRef = React.useRef(null);
            const breakPickerRef = React.useRef(null);
            
            
            // 다크 모드 설정
            React.useEffect(() => {
                if (isDarkMode) {
                    document.body.classList.add('dark-theme');
                    document.body.classList.remove('light-theme');
                } else {
                    document.body.classList.add('light-theme');
                    document.body.classList.remove('dark-theme');
                }
            }, [isDarkMode]);
            
            // 모드에 따른 배경색 설정
            React.useEffect(() => {
                if (mode === 'focus') {
                    document.body.classList.remove('break-mode');
                } else {
                    document.body.classList.add('break-mode');
                }
                
                // 모드 변경 시 타이머 다시 그리기
                updateSVG();
            }, [mode]);

            // 피커 값을 주기적으로 확인하는 useEffect 추가
            React.useEffect(() => {
                const checkPickerValues = () => {
                    if (focusPickerRef.current && !isRunning) {
                        const scrollTop = focusPickerRef.current.scrollTop;
                        const itemHeight = 40;
                        const index = Math.round(scrollTop / itemHeight);
                        
                        if (focusTime !== index) {
                            setFocusTime(index);
                            if (mode === 'focus') {
                                setTimeLeft(index * 60);
                                updateSVG();
                            }
                        }
                    }
                    
                    if (breakPickerRef.current && !isRunning) {
                        const scrollTop = breakPickerRef.current.scrollTop;
                        const itemHeight = 40;
                        const index = Math.round(scrollTop / itemHeight);
                        
                        if (breakTime !== index) {
                            setBreakTime(index);
                            if (mode === 'break') {
                                setTimeLeft(index * 60);
                                updateSVG();
                            }
                        }
                    }
                };
                
                // 200ms마다 피커 값을 확인
                const intervalId = setInterval(checkPickerValues, 200);
                
                return () => clearInterval(intervalId);
            }, [focusTime, breakTime, mode, isRunning]);
            
            
            // 시간 포맷팅 함수
            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            };
            
            // 업데이트 함수
                const updateSVG = React.useCallback(() => {
                    const svg = svgRef.current;
                    if (!svg) return;
                    
                    // SVG 내용 초기화
                    while (svg.firstChild) {
                        svg.removeChild(svg.firstChild);
                    }
                    
                    const centerX = 300;
                    const centerY = 300;
                    const radius = 220;
                    
                    // 메인 모드일 때는 테마에 따라, 휴식 모드일 때는 반전
                    const isBreakMode = mode === 'break';
                    const shouldUseDarkTheme = (isDarkMode && !isBreakMode) || (!isDarkMode && isBreakMode);
                    
                    // 배경 원 그리기
                    const backgroundCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    backgroundCircle.setAttribute("cx", centerX);
                    backgroundCircle.setAttribute("cy", centerY);
                    backgroundCircle.setAttribute("r", radius);
                    backgroundCircle.setAttribute("fill", shouldUseDarkTheme ? '#333' : '#e0e0e0');
                    backgroundCircle.style.pointerEvents = "none";
                    svg.appendChild(backgroundCircle);
                    
                    // 진행 상황에 따른 원형 차트 그리기
                    if (timeLeft > 0 && totalTime > 0) { // 0으로 나누는 오류 방지
                        let progress = timeLeft / totalTime;
                        if (progress === 1) {
                        progress = 0.9999; // 완전한 원 말고 거의 다 찬 원으로
                        }
                    
                    // 원형 차트의 각도 계산
                    const startAngle = -Math.PI / 2; // 12시 방향에서 시작
                    const endAngle = startAngle + (2 * Math.PI * progress); // 진행도에 따라 각도 계산
                    
                    // SVG 경로 생성
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    
                    // 중심점
                    const x0 = centerX;
                    const y0 = centerY;
                    
                    // 시작점 (12시 방향)
                    const x1 = centerX;
                    const y1 = centerY - radius;
                    
                    // 종료점 (진행 각도에 따라 계산)
                    const x2 = centerX + radius * Math.cos(endAngle);
                    const y2 = centerY + radius * Math.sin(endAngle);
                    
                    // 큰 호인지 작은 호인지 결정 (180도 초과 여부)
                    const largeArcFlag = progress > 0.5 ? 1 : 0;
                    
                    // SVG 경로 데이터 생성
                    const d = [
                        `M ${x0} ${y0}`, // 중심점으로 이동
                        `L ${x1} ${y1}`, // 시작점으로 선 그리기
                        `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`, // 호 그리기
                        'Z' // 경로 닫기 (중심점으로 다시 연결)
                    ].join(' ');
                    
                    path.setAttribute("d", d);
                    path.setAttribute("fill", timerColor === 'red' ? '#ff4d4d' : '#4caf50');
                    path.style.pointerEvents = "none";
                    svg.appendChild(path);
                }
                
                // 눈금 그리기 (showTicks가 true일 때만)
                if (showTicks) {
                    for (let i = 0; i < 60; i++) {
                        const angle = (i * 6 - 90) * (Math.PI / 180);
                        const inner = i % 5 === 0 ? radius + 4 : radius + 8;
                        const outer = i % 5 === 0 ? radius + 28 : radius + 14;
                        const x1 = centerX + inner * Math.cos(angle);
                        const y1 = centerY + inner * Math.sin(angle);
                        const x2 = centerX + outer * Math.cos(angle);
                        const y2 = centerY + outer * Math.sin(angle);
                        
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", x1);
                        line.setAttribute("y1", y1);
                        line.setAttribute("x2", x2);
                        line.setAttribute("y2", y2);
                        line.setAttribute("stroke", shouldUseDarkTheme ? '#fff' : '#333');
                        line.setAttribute("stroke-width", i % 5 === 0 ? 3 : 1);
                        line.style.pointerEvents = "none";
                        svg.appendChild(line);
                    }
                }
                
                // 숫자 그리기 (showNumbers가 true일 때만)
                if (showNumbers) {
                    for (let i = 0; i < 12; i++) {
                        const text = (i * 5).toString();
                        const angle = (i * 30 - 90) * (Math.PI / 180);
                        const tx = centerX + (radius + 50) * Math.cos(angle);
                        const ty = centerY + (radius + 50) * Math.sin(angle);
                        
                        const textElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        textElement.setAttribute("x", tx);
                        textElement.setAttribute("y", ty);
                        textElement.setAttribute("fill", shouldUseDarkTheme ? '#fff' : '#333');
                        textElement.setAttribute("font-size", "24px");
                        textElement.setAttribute("text-anchor", "middle");
                        textElement.setAttribute("dominant-baseline", "middle");
                        textElement.textContent = text;
                        textElement.style.pointerEvents = "none";
                        textElement.style.userSelect = "none";
                        textElement.style.webkitUserSelect = "none";
                        textElement.style.mozUserSelect = "none";
                        textElement.style.msUserSelect = "none";
                        svg.appendChild(textElement);
                    }
                }

            }, [timeLeft, totalTime, timerColor, showTicks, showNumbers, isPaused, isDarkMode, mode]);

            
            // 드래그로 시간 설정
            React.useEffect(() => {
                const svg = svgRef.current;
                const timePreview = timePreviewRef.current;
                if (!svg || !timePreview) return;
                let isDragging = false;
                
                const handleMouseDown = (e) => {
                    if (isRunning) return; // 타이머 실행 중에는 설정 불가
                    
                    const rect = svg.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // 중심점과 거리 계산
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 차트 내부인지 확인 (원 안에 있는지)
                    // SVG viewBox가 600x600이고 원 반지름이 220인 경우 비율 계산
                    const radius = (220 / 600) * rect.width;
                    
                    // 원 안에 있는 경우에만 드래그 시작
                    if (distance <= radius) {
                        isDragging = true;
                        updatePreviewFromCoords(x, y);
                    }
                };
                
                const handleMouseMove = (e) => {
                    if (!isDragging || isRunning) return;
                    
                    const rect = svg.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    updatePreviewFromCoords(x, y);
                };
                
                const handleMouseUp = () => {
                    if (!isDragging || isRunning) return;
                    
                    isDragging = false;
                    timePreview.style.display = 'none';
                };
                
                const handleTouchStart = (e) => {
                    if (isRunning) return;
                    e.preventDefault();
                    
                    const svg = svgRef.current;
                    const rect = svg.getBoundingClientRect();
                    const touch = e.touches[0];
                    
                    // 터치 위치 계산
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // 중심점과 거리 계산
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 차트 내부인지 확인 (원 안에 있는지)
                    // SVG viewBox가 600x600이고 원 반지름이 220인 경우 비율 계산
                    const radius = (220 / 600) * rect.width;
                    
                    // 원 안에 있는 경우에만 드래그 시작
                    if (distance <= radius) {
                        isDragging = true;
                        updatePreviewFromCoords(x, y);
                    }
                };

                const handleTouchMove = (e) => {
                    // 드래그 중이 아니거나 타이머가 실행 중이면 무시
                    if (!isDragging || isRunning) return;
                    
                    // 기본 동작 방지 (스크롤 등)
                    e.preventDefault();
                    
                    const svg = svgRef.current;
                    const rect = svg.getBoundingClientRect();
                    const touch = e.touches[0];
                    
                    // 터치 위치 계산
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // 좌표 업데이트 (원 안/밖 상관없이 진행)
                    updatePreviewFromCoords(x, y);
                };

                const handleTouchEnd = (e) => {
                    if (!isDragging || isRunning) return;
                    
                    e.preventDefault();
                    isDragging = false;
                    timePreview.style.display = 'none';
                };
                
                // 좌표로부터 시간 설정 및 미리보기 업데이트
                const updatePreviewFromCoords = (x, y) => {
                    if (!svgRef.current) return;
                    if (isNaN(x) || isNaN(y)) return;

                    const svg = svgRef.current;

                    const centerX = svg.clientWidth / 2;
                    const centerY = svg.clientHeight / 2;

                    const dx = x - centerX;
                    const dy = y - centerY;
                    let angle = Math.atan2(dy, dx);

                    angle = angle < -0.5 * Math.PI ? angle + 2 * Math.PI : angle;

                    const percent = (angle + 0.5 * Math.PI) / (2 * Math.PI);
                    const mins = Math.max(0, Math.min(60, Math.round(percent * 60)));

                    const timePreview = timePreviewRef.current;
                    timePreview.textContent = `${mins.toString().padStart(2, '0')}:00`;
                    timePreview.style.display = 'block';

                    const newTimeInSeconds = mins * 60;
                    setTimeLeft(newTimeInSeconds);

                    while (svg.firstChild) {
                        svg.removeChild(svg.firstChild);
                    }

                    const centerXSVG = 300;
                    const centerYSVG = 300;
                    const radius = 220;

                    const isBreakMode = mode === 'break';
                    const shouldUseDarkTheme = (isDarkMode && !isBreakMode) || (!isDarkMode && isBreakMode);

                    const backgroundCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    backgroundCircle.setAttribute("cx", centerXSVG);
                    backgroundCircle.setAttribute("cy", centerYSVG);
                    backgroundCircle.setAttribute("r", radius);
                    backgroundCircle.setAttribute("fill", shouldUseDarkTheme ? '#333' : '#e0e0e0');
                    backgroundCircle.style.pointerEvents = "none"; // 추가: 포인터 이벤트 무시
                    svg.appendChild(backgroundCircle);

                    let timeRatio = newTimeInSeconds / 3600;
                    if (Math.round(newTimeInSeconds) === 3600) {
                        timeRatio = 0.9999;
                    }
                    const startAngle = -Math.PI / 2;
                    const endAngle = startAngle + (2 * Math.PI * timeRatio);

                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");

                    const x0 = centerXSVG;
                    const y0 = centerYSVG;
                    const x1 = centerXSVG;
                    const y1 = centerYSVG - radius;
                    const x2 = centerXSVG + radius * Math.cos(endAngle);
                    const y2 = centerYSVG + radius * Math.sin(endAngle);
                    const largeArcFlag = timeRatio > 0.5 ? 1 : 0;

                    const d = [
                        `M ${x0} ${y0}`,
                        `L ${x1} ${y1}`,
                        `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`,
                        'Z'
                    ].join(' ');

                    path.setAttribute("d", d);
                    path.setAttribute("fill", timerColor === 'red' ? '#ff4d4d' : '#4caf50');
                    path.style.pointerEvents = "none"; // 추가: 포인터 이벤트 무시
                    svg.appendChild(path);

                    if (showTicks) {
                        for (let i = 0; i < 60; i++) {
                            const angle = (i * 6 - 90) * (Math.PI / 180);
                            const inner = i % 5 === 0 ? radius + 4 : radius + 8;
                            const outer = i % 5 === 0 ? radius + 28 : radius + 14;
                            const x1 = centerXSVG + inner * Math.cos(angle);
                            const y1 = centerYSVG + inner * Math.sin(angle);
                            const x2 = centerXSVG + outer * Math.cos(angle);
                            const y2 = centerYSVG + outer * Math.sin(angle);

                            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("x1", x1);
                            line.setAttribute("y1", y1);
                            line.setAttribute("x2", x2);
                            line.setAttribute("y2", y2);
                            line.setAttribute("stroke", shouldUseDarkTheme ? '#fff' : '#333');
                            line.setAttribute("stroke-width", i % 5 === 0 ? 3 : 1);
                            line.style.pointerEvents = "none"; // 추가: 포인터 이벤트 무시
                            svg.appendChild(line);
                        }
                    }

                    if (showNumbers) {
                        for (let i = 0; i < 12; i++) {
                            const text = (i * 5).toString();
                            const angle = (i * 30 - 90) * (Math.PI / 180);
                            const tx = centerXSVG + (radius + 50) * Math.cos(angle);
                            const ty = centerYSVG + (radius + 50) * Math.sin(angle);

                            const textElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            textElement.setAttribute("x", tx);
                            textElement.setAttribute("y", ty);
                            textElement.setAttribute("fill", shouldUseDarkTheme ? '#fff' : '#333');
                            textElement.setAttribute("font-size", "24px");
                            textElement.setAttribute("text-anchor", "middle");
                            textElement.setAttribute("dominant-baseline", "middle");
                            textElement.textContent = text;
                            textElement.style.pointerEvents = "none"; // 추가: 포인터 이벤트 무시
                            textElement.style.userSelect = "none";
                            textElement.style.webkitUserSelect = "none";
                            textElement.style.mozUserSelect = "none";
                            textElement.style.msUserSelect = "none";
                            svg.appendChild(textElement);
                        }
                    }

                    if (mode === 'focus') {
                        setFocusTime(mins);
                    } else {
                        setBreakTime(mins);
                    }
                };

                
                // 이벤트 리스너 추가
                svg.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                svg.addEventListener('touchstart', handleTouchStart, { passive: false });
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd, { passive: false });
                
                return () => {
                    svg.removeEventListener('mousedown', handleMouseDown);
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    
                    svg.removeEventListener('touchstart', handleTouchStart);
                    document.removeEventListener('touchmove', handleTouchMove);
                    document.removeEventListener('touchend', handleTouchEnd);
                };
            }, [isRunning, mode, isDarkMode, showTicks, showNumbers, timerColor]);
            
            // 휠 피커 초기화
            React.useEffect(() => {
                if (focusPickerRef.current) {
                const scrollPos = focusTime * 40;
                focusPickerRef.current.scrollTop = scrollPos;
                }
                 if (breakPickerRef.current) {
                const scrollPos = breakTime * 40;
                breakPickerRef.current.scrollTop = scrollPos;
                }
            }, [focusTime, breakTime]);
            
            // 휠 피커 아이템 렌더링
            const renderPickerItems = (max, value, onChange) => {
                const items = [];
                for (let i = 0; i <= max; i++) { // 0부터 max까지 (60 포함)
                    items.push(
                        <div 
                            key={i} 
                            className={`picker-item ${i === value ? 'selected' : ''}`}
                            onClick={() => {
                                if (!isRunning || isPaused) {
                                    onChange(i);
                                    if ((mode === 'focus' && onChange === setFocusTime) || 
                                        (mode === 'break' && onChange === setBreakTime)) {
                                        setTimeLeft(i * 60);
                                        // 차트 즉시 업데이트
                                        updateChartDirectly(i);
                                    }
                                }
                            }}
                        >
                            {i}
                        </div>
                    );
                }
                return items;
            };
            
            // 오디오 요소 생성
            React.useEffect(() => {
                // 알림음
                const focusAudio = new Audio("https://ryan-g00.github.io/pomodoro/dingdong.mp3");
                const breakAudio = new Audio("https://ryan-g00.github.io/pomodoro/beep.mp3");
                
                focusAudioRef.current = focusAudio;
                breakAudioRef.current = breakAudio;
                
                return () => {
                    focusAudio.pause();
                    breakAudio.pause();
                };
            }, []);
            
            // 타이머 시작
            const startTimer = async () => {
                if ('wakeLock' in navigator) {
                    try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    } catch (err) {
                    }
                }

            
            // ✅ 사파리용 오디오 재생 권한 확보 (무음 재생)
            if (focusAudioRef.current && breakAudioRef.current) {
                try {
                // focus audio
                // 0.1로 했더니 간간히 짧게 들리는 현상 발생함. 0.001로 변경
                focusAudioRef.current.volume = 0.001;
                focusAudioRef.current.currentTime = 0;
                focusAudioRef.current.play()
                    .then(() => {
                    focusAudioRef.current.pause();
                    focusAudioRef.current.currentTime = 0;
                    focusAudioRef.current.volume = 1; // 원래대로 복구
                    })
                    .catch(() => {});

                breakAudioRef.current.volume = 0.01;
                breakAudioRef.current.currentTime = 0;
                breakAudioRef.current.play()
                    .then(() => {
                    breakAudioRef.current.pause();
                    breakAudioRef.current.currentTime = 0;
                    breakAudioRef.current.volume = 1;
                    })
                    .catch(() => {});
                } catch (err) {
                console.warn("Audio warm-up failed:", err);
                }
            }

            if (allSetsCompleted) {
                // 세트가 모두 끝난 경우: 타이머와 세트 초기화
                const newTime = focusTime * 60;
                setTimeLeft(newTime);
                setTotalTime(newTime);
                setCurrentSet(0);
                setMode('focus');
                setAllSetsCompleted(false);
    }

            // 타이머 시작
            if (!isRunning) {
                setIsRunning(true);
                setIsPaused(false);
            }
            };


            // 타이머 시작 직전
            const handleUserInteraction = () => {
            // 한 번 재생 후 바로 중단 사파리 소리 재생 문제 해결 위해..
            if (focusAudioRef.current) {
                focusAudioRef.current.volume = 0.01;
                focusAudioRef.current.play().then(() => {
                focusAudioRef.current.pause();
                focusAudioRef.current.currentTime = 0;
                }).catch(() => {});
            }
            };
            
            // 타이머 일시정지
            const pauseTimer = () => {
                setIsRunning(false);
                setIsPaused(true);

                // 타이머 멈추면 Wake Lock 해제
                if (wakeLock) {
                    wakeLock.release().then(() => {
                    wakeLock = null;
                    });
                }
                };
            
            // 타이머 리셋
            const resetTimer = () => {
                setIsRunning(false);
                setIsPaused(false);
                setTimeLeft(mode === 'focus' ? focusTime * 60 : breakTime * 60);
                setAllSetsCompleted(false); // 타이머 리셋 시 세트 완료 상태 초기화
                updateSVG();
            };
            
            // 세트 증가/감소 핸들러
            const handleDecreaseSets = () => {
                if (sets > 1 && !isRunning) {
                    setSets(prev => prev - 1);
                }
            };
            
            const handleIncreaseSets = () => {
                if (sets < 10 && !isRunning) {
                    setSets(prev => prev + 1);
                }
            };
            
            // 타이머 애니메이션
            React.useEffect(() => {
                let intervalId = null;
                
                if (isRunning) {
                    const startTime = Date.now();
                    const initialTimeLeft = timeLeft;
                    
                    intervalId = setInterval(() => {
                        const elapsedSeconds = (Date.now() - startTime) / 1000;
                        const newTimeLeft = Math.max(0, initialTimeLeft - elapsedSeconds);
                        
                        setTimeLeft(newTimeLeft);
                        updateSVG();
                        
                        if (newTimeLeft <= 0) {
                            clearInterval(intervalId);
                            setIsRunning(false);
                            
                            // 타이머 종료 시 알림
                            if (soundEnabled) {
                                if (mode === 'focus') {
                                    focusAudioRef.current.play();
                                } else {
                                    breakAudioRef.current.play();
                                }
                            }
                            
                            if (vibrationEnabled && navigator.vibrate) {
                                navigator.vibrate([200, 100, 200]);
                            }
                            
                            // 모드 전환
                            if (mode === 'focus') {
                                // 집중 모드가 끝나면 세트 카운트 증가
                                if (currentSet < sets) {
                                    setCurrentSet(prev => prev + 1);
                                } else {
                                    setAllSetsCompleted(true); // 모든 세트 완료 표시
                                }

                                setMode('break');
                                setTimeLeft(breakTime * 60);
                                
                                // 자동 시작 기능
                                if (autoStart && !allSetsCompleted) {
                                    setTimeout(() => {
                                        setIsRunning(true);
                                    }, 500);
                                }
                            } else {
                                // 휴식 모드가 끝난 후
                                if (currentSet < sets) {
                                    // 아직 세트가 남아있으면
                                    setMode('focus');
                                    setTimeLeft(focusTime * 60);
                                    
                                    // 자동 시작 기능
                                    if (autoStart && !allSetsCompleted) {
                                        setTimeout(() => {
                                            setIsRunning(true);
                                        }, 500);
                                    }
                                } else {
                                    // 모든 세트가 완료되면
                                    setMode('focus');
                                    setTimeLeft(focusTime * 60);
                                    setAllSetsCompleted(true); // 모든 세트 완료 표시
                                }
                            }
                        }
                    }, 100); // 100ms마다 업데이트
                } else {
                    updateSVG();
                }
                
                return () => {
                    if (intervalId) {
                        clearInterval(intervalId);
                    }
                };
            }, [isRunning, mode, focusTime, breakTime, sets, currentSet, soundEnabled, vibrationEnabled, totalTime, timeLeft, autoStart, allSetsCompleted, updateSVG]);
            
            // 컴포넌트 마운트 시 타이머 그리기
            React.useEffect(() => {
                if (svgRef.current) {
                    // SVG 요소 자체에는 이벤트를 받도록 설정
                    svgRef.current.style.pointerEvents = "auto";
                }
                setTotalTime(3600);
                updateSVG();
            }, [updateSVG]);
            
            // 토글 스위치 컴포넌트
            const ToggleSwitch = ({ label, checked, onChange, id, disabled }) => {
                return (
                    <div className="toggle-container">
                        <span id={`${id}-label`}>{label}</span>
                        <label className="toggle-switch" htmlFor={id}>
                            <input 
                                id={id}
                                name={id}
                                type="checkbox" 
                                checked={checked} 
                                onChange={onChange}
                                aria-labelledby={`${id}-label`}
                                disabled={disabled}
                            />
                            <span className="toggle-slider"></span>
                        </label>
                    </div>
                );
            };
            
            return (
                <div className="app-container">
                    <button 
                        className="menu-button"
                        onClick={() => setIsSidebarOpen(true)}
                        aria-label="설정 메뉴 열기"
                        id="menu-button"
                    >
                        ☰
                    </button>
                    
                    <div 
                        className={`overlay ${isSidebarOpen ? 'active' : ''}`}
                        onClick={() => setIsSidebarOpen(false)}
                        aria-hidden="true"
                    ></div>
                    
                    <div className={`sidebar ${isSidebarOpen ? 'open' : ''}`} aria-label="설정 메뉴">
                        <div className="sidebar-header">
                            <h1 id="settings-header">설정</h1>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="time-settings-header">시간 설정</h2>
                            <div className="time-pickers">
                                <div className="time-picker">
                                    <label className="time-picker-label" htmlFor="focus-time-picker">집중 시간 (분)</label>
                                    <div className="picker-container">
                                        <div className="picker-highlight"></div>
                                        <div 
                                            id="focus-time-picker"
                                            className="picker-values" 
                                            ref={focusPickerRef}
                                            onTouchStart={(e) => e.stopPropagation()}
                                        >
                                            {renderPickerItems(60, focusTime, (value) => {
                                                if (!isRunning) {
                                                    setFocusTime(value);
                                                    if (mode === 'focus') {
                                                        setTimeLeft(value * 60);
                                                        setTotalTime(value * 60);
                                                        updateSVG();
                                                    }
                                                }
                                            })}
                                        </div>
                                    </div>
                                </div>
                                <div className="time-picker">
                                    <label className="time-picker-label" htmlFor="break-time-picker">휴식 시간 (분)</label>
                                    <div className="picker-container">
                                        <div className="picker-highlight"></div>
                                        <div 
                                            id="break-time-picker"
                                            className="picker-values" 
                                            ref={breakPickerRef}
                                            onTouchStart={(e) => e.stopPropagation()}
                                        >
                                            {renderPickerItems(60, breakTime, (value) => {
                                                if (!isRunning) {
                                                    setBreakTime(value);
                                                    if (mode === 'break') {
                                                        setTimeLeft(value * 60);
                                                        setTotalTime(value * 60);
                                                        updateSVG();
                                                    }
                                                }
                                            })}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning? 'disabled' : ''}`}>
                            <h2 id="mode-selection-header">모드 선택</h2>
                            <div className="mode-selector" role="group" aria-labelledby="mode-selection-header">
                                <button 
                                    id="focus-mode-button"
                                    name="focus-mode"
                                    className={`mode-button ${mode === 'focus' ? 'active' : ''}`}
                                    onClick={() => {
                                        if (!isRunning) {
                                            setMode('focus');
                                            setTimeLeft(focusTime * 60);
                                            updateSVG();
                                        }
                                    }}
                                    disabled={isRunning}
                                    aria-pressed={mode === 'focus'}
                                >
                                    집중
                                </button>
                                <button 
                                    id="break-mode-button"
                                    name="break-mode"
                                    className={`mode-button ${mode === 'break' ? 'active' : ''}`}
                                    onClick={() => {
                                        if (!isRunning) {
                                            setMode('break');
                                            setTimeLeft(breakTime * 60);
                                            updateSVG();
                                        }
                                    }}
                                    disabled={isRunning}
                                    aria-pressed={mode === 'break'}
                                >
                                    휴식
                                </button>
                            </div>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="sets-setting-header">세트 설정</h2>
                            <div className="sets-container">
                                <label htmlFor="sets-counter" className="sets-label">반복 횟수</label>
                                <div id="sets-counter" className="sets-counter">
                                    <button 
                                        className="sets-button" 
                                         onClick={handleDecreaseSets}
                                         disabled={sets <= 1 || isRunning}
                                        aria-label="반복 횟수 감소"
                                    >
                                         -
                                    </button>
                                    <div className="sets-value" aria-live="polite">
                                        {sets}
                                    </div>
                                    <button 
                                        className="sets-button"
                                        onClick={handleIncreaseSets}
                                        disabled={sets >= 10 || isRunning || isPaused}
                                        aria-label="반복 횟수 증가"
                                    >
                                        +
                                    </button>
                                </div>
                            </div>
                            <div className="toggle-container" style={{ marginTop: '10px' }}>
                                <span id="auto-start-label">자동 시작</span>
                                <label className="toggle-switch" htmlFor="auto-start-toggle">
                                    <input 
                                        id="auto-start-toggle"
                                        name="auto-start-toggle"
                                        type="checkbox" 
                                        checked={autoStart} 
                                        onChange={() => {
                                            if (!isRunning) {
                                                setAutoStart(prev => !prev);
                                            }
                                        }}
                                        disabled={isRunning}
                                        aria-labelledby="auto-start-label"
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="theme-setting-header">테마 설정</h2>
                            <ToggleSwitch 
                                id="dark-mode-toggle"
                                label="다크 모드" 
                                checked={isDarkMode} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setIsDarkMode(prev => !prev);
                                    }
                                }}
                                disabled={isRunning}
                            />
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="color-selection-header">차트 색상 선택</h2>
                            <div className="color-options" role="radiogroup" aria-labelledby="color-selection-header">
                                <div 
                                    className={`color-option red ${timerColor === 'red' ? 'selected' : ''}`}
                                    onClick={() => {
                                        if (!isRunning) {
                                            setTimerColor('red');
                                            updateSVG();
                                        }
                                    }}
                                    role="radio"
                                    aria-checked={timerColor === 'red'}
                                    tabIndex={timerColor === 'red' ? 0 : -1}
                                    aria-label="빨간색"
                                    id="red-color-option"
                                ></div>
                                <div 
                                    className={`color-option green ${timerColor === 'green' ? 'selected' : ''}`}
                                    onClick={() => {
                                        if (!isRunning) {
                                            setTimerColor('green');
                                            updateSVG();
                                        }
                                    }}
                                    role="radio"
                                    aria-checked={timerColor === 'green'}
                                    tabIndex={timerColor === 'green' ? 0 : -1}
                                    aria-label="초록색"
                                    id="green-color-option"
                                ></div>
                            </div>
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="notifications-header">알림 설정</h2>
                            <ToggleSwitch 
                                id="sound-toggle"
                                label="소리 알림" 
                                checked={soundEnabled} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setSoundEnabled(prev => !prev);
                                    }
                                }}
                                disabled={isRunning}
                            />
                            <ToggleSwitch 
                                id="vibration-toggle"
                                label="진동 알림" 
                                checked={vibrationEnabled} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setVibrationEnabled(prev => !prev);
                                    }
                                }}
                                disabled={isRunning}
                            />
                        </div>
                        
                        <div className={`sidebar-section ${isRunning && !isPaused ? 'disabled' : ''}`}>
                            <h2 id="display-settings-header">표시 설정</h2>
                            <ToggleSwitch 
                                id="ticks-toggle"
                                label="눈금 표시" 
                                checked={showTicks} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setShowTicks(prev => !prev);
                                        updateSVG();
                                    }
                                }}
                                disabled={isRunning}
                            />
                            <ToggleSwitch 
                                id="numbers-toggle"
                                label="시간 숫자 표시" 
                                checked={showNumbers} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setShowNumbers(prev => !prev);
                                        updateSVG();
                                    }
                                }}
                                disabled={isRunning}
                            />
                            <ToggleSwitch 
                                id="time-display-toggle"
                                label="실시간 시간 표시" 
                                checked={showTimeDisplay} 
                                onChange={() => {
                                    if (!isRunning) {
                                        setShowTimeDisplay(prev => !prev);
                                    }
                                }}
                                disabled={isRunning}
                            />
                        </div>
                    </div>
                    
                    <div className="timer-container" style={{ touchAction: 'none' }}>
                        <div className="timer-display">
                            <svg 
                                ref={svgRef}
                                className="timer-svg"
                                viewBox="0 0 600 600"
                                xmlns="http://www.w3.org/2000/svg"
                                aria-label="뽀모도로 타이머 시각화"
                                role="img"
                                style={{ touchAction: 'none' }}
                            ></svg>
                            
                            <div 
                                ref={timePreviewRef}
                                className="time-preview"
                                aria-live="polite"
                                aria-atomic="true"
                            ></div>
                            
                            {showTimeDisplay && (
                                <div 
                                    className="timer-time"
                                    aria-live="polite"
                                    aria-atomic="true"
                                    role="timer"
                                    aria-label={`현재 시간: ${formatTime(timeLeft)}`}
                                >
                                    {formatTime(timeLeft)}
                                </div>
                            )}
                            
                            <div
                            className="set-display"
                            aria-live="polite"
                            aria-atomic="true">
                                {currentSet}/{sets} 세트 - {mode === 'focus' ? '집중' : '휴식'}
                            </div>
                        </div>

                        {isPaused && !isRunning && (
                                <div
                                style={{
                                    position: 'absolute',
                                    top: '300px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: '20px',
                                    color: isDarkMode ? '#fff' : '#333',
                                }}
                                >
                                일시정지됨
                                </div>
                            )}

                       <div className="timer-actions">
                        <button 
                            className="timer-button" 
                            onClick={isRunning ? pauseTimer : startTimer}
                            aria-label={isRunning ? "일시정지" : "시작"}
                            id="play-pause-button"
                        >
                            {isRunning ? '∥' : '▶'}
                        </button>

                        {isPaused && (
                        <button className="timer-button" onClick={resetTimer}>↺</button>
                        )}

                        </div>
                    </div>
                </div>
            );
        };
        // 앱 렌더링 기모링~
        const rootElement = document.getElementById('root');
        ReactDOM.render(React.createElement(App), rootElement);
    </script>
</body>
</html>